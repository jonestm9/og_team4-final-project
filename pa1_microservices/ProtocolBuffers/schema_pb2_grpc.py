# Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!
"""Client and server classes corresponding to protobuf-defined services."""
import grpc

import schema_pb2 as schema__pb2


class DummyServiceStub(object):
    """Note that in our programming assignment we have more than one message type
    (Grocery and Health).  Thus, you might want to use an enumerated type to
    first include the message type. ProtocolBuffers also includes a "OneOf"
    feature in which a field can be one of many different choices. In this way
    you could define a message for grocery msg body and health msg body, and
    declare these as one of fields in this top level message. When serializing
    and deserializing, you consult the message type field and take actions
    appropriately.  

    Note that in your assignment, since you will have at least two separate types of 
    There is no "top level" root structure as in FlatBufs. We decide what is top for us

    Protocol Buffers also allow the facility to define services so as to support
    remote procedure calls. This did not exist in FlatBufs, but we declare one
    here as gRPC is a remote procedure call approach where the service must
    provide an interface declaring what is accepted as a request and what goes
    back as a response for that request. A response can comprise empty field if
    nothing is expected as a response.

    """

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.method = channel.unary_unary(
                '/DummyService/method',
                request_serializer=schema__pb2.Master.SerializeToString,
                response_deserializer=schema__pb2.Master.FromString,
                )


class DummyServiceServicer(object):
    """Note that in our programming assignment we have more than one message type
    (Grocery and Health).  Thus, you might want to use an enumerated type to
    first include the message type. ProtocolBuffers also includes a "OneOf"
    feature in which a field can be one of many different choices. In this way
    you could define a message for grocery msg body and health msg body, and
    declare these as one of fields in this top level message. When serializing
    and deserializing, you consult the message type field and take actions
    appropriately.  

    Note that in your assignment, since you will have at least two separate types of 
    There is no "top level" root structure as in FlatBufs. We decide what is top for us

    Protocol Buffers also allow the facility to define services so as to support
    remote procedure calls. This did not exist in FlatBufs, but we declare one
    here as gRPC is a remote procedure call approach where the service must
    provide an interface declaring what is accepted as a request and what goes
    back as a response for that request. A response can comprise empty field if
    nothing is expected as a response.

    """

    def method(self, request, context):
        """Missing associated documentation comment in .proto file."""
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')


def add_DummyServiceServicer_to_server(servicer, server):
    rpc_method_handlers = {
            'method': grpc.unary_unary_rpc_method_handler(
                    servicer.method,
                    request_deserializer=schema__pb2.Master.FromString,
                    response_serializer=schema__pb2.Master.SerializeToString,
            ),
    }
    generic_handler = grpc.method_handlers_generic_handler(
            'DummyService', rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))


 # This class is part of an EXPERIMENTAL API.
class DummyService(object):
    """Note that in our programming assignment we have more than one message type
    (Grocery and Health).  Thus, you might want to use an enumerated type to
    first include the message type. ProtocolBuffers also includes a "OneOf"
    feature in which a field can be one of many different choices. In this way
    you could define a message for grocery msg body and health msg body, and
    declare these as one of fields in this top level message. When serializing
    and deserializing, you consult the message type field and take actions
    appropriately.  

    Note that in your assignment, since you will have at least two separate types of 
    There is no "top level" root structure as in FlatBufs. We decide what is top for us

    Protocol Buffers also allow the facility to define services so as to support
    remote procedure calls. This did not exist in FlatBufs, but we declare one
    here as gRPC is a remote procedure call approach where the service must
    provide an interface declaring what is accepted as a request and what goes
    back as a response for that request. A response can comprise empty field if
    nothing is expected as a response.

    """

    @staticmethod
    def method(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/DummyService/method',
            schema__pb2.Master.SerializeToString,
            schema__pb2.Master.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
